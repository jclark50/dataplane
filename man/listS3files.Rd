% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/file_utils.R, R/listS3files.R
\name{listS3files}
\alias{listS3files}
\title{List S3 objects with retries and optional ordering}
\usage{
listS3files(
  bucket,
  prefix = NULL,
  delimiter = NULL,
  max = NULL,
  marker = NULL,
  ...,
  max_tries = 3,
  wait = 1,
  backoff = 1.6,
  verbose = TRUE,
  order_by_last_modified = FALSE,
  return_tail = FALSE,
  tail_n = 6
)

listS3files(
  bucket,
  prefix = NULL,
  delimiter = NULL,
  max = NULL,
  marker = NULL,
  ...,
  max_tries = 3,
  wait = 1,
  backoff = 1.6,
  verbose = TRUE,
  order_by_last_modified = FALSE,
  return_tail = FALSE,
  tail_n = 6
)
}
\arguments{
\item{bucket}{Character. S3 bucket name.}

\item{prefix}{Character, optional. Limit results to keys beginning with this prefix.}

\item{delimiter}{Character, optional. E.g., `"/"` to group by common prefixes.}

\item{max}{Integer, optional. Maximum number of keys to return (per request).}

\item{marker}{Character, optional. Key to start with when listing.}

\item{...}{Passed through to [aws.s3::get_bucket()] (e.g., credentials, region).}

\item{max_tries}{Integer. Maximum attempts before failing. Default `3`.}

\item{wait}{Numeric (seconds). Initial wait between attempts. Default `1`.}

\item{backoff}{Numeric multiplier for exponential backoff. Default `1.6`.}

\item{verbose}{Logical. If `TRUE`, prints retry messages. Default `TRUE`.}

\item{order_by_last_modified}{Logical. If `TRUE`, sort ascending by `LastModified`.
Default `FALSE`.}

\item{return_tail}{Logical. If `TRUE`, return only the last `tail_n` rows
*after* optional sorting. Default `FALSE`.}

\item{tail_n}{Integer. Number of rows to return when `return_tail = TRUE`.
Default `6`.}
}
\value{
A data.frame with columns: `Key`, `Size`, `LastModified`, `StorageClass`.

A `data.frame` with columns:
- `Key` (character)
- `Size` (numeric; `NA` for common prefixes)
- `LastModified` (POSIXct, UTC; `NA` if absent)
- `StorageClass` (character; `NA` if absent)
}
\description{
Wrapper around `aws.s3::get_bucket()` that:
\itemize{
  \item supports basic pagination via `marker`
  \item retries transient failures with backoff
  \item returns a data frame with `Key`, `Size`, `LastModified`, `StorageClass`
  \item can order by `LastModified` and/or return only the tail rows
}

Lists objects from an S3 bucket/prefix using **aws.s3**, avoiding the
`Owner$ID` assumption that can trigger `subscript out of bounds` when
`Owner` is omitted. Adds retries and (optionally) sorts by `LastModified`
and returns only the newest rows.
}
\details{
Calls [aws.s3::get_bucket()] with `parse_response = TRUE` and converts the
parsed list into a data frame while ignoring any `Owner` fields. Handles
"folder" entries by falling back to `Name` or `Prefix` when `Key` is absent.
Timestamps are parsed to UTC when present.

Note: this issues a single ListObjects request (no pagination). For >1,000
keys, loop with `marker`/continuation tokens.
}
\examples{
\dontrun{
df <- listS3files(bucket = "my-bucket", prefix = "data/2026-01-01/")
newest <- listS3files("my-bucket", prefix = "data/", order_by_last_modified = TRUE, return_tail = TRUE, tail_n = 5)
}

\dontrun{
# Basic
df <- safe_get_bucket_df("my-bucket", prefix = "hrrr/20250809/")

# Newest few objects (sorted by LastModified, tail 6)
newest <- safe_get_bucket_df("my-bucket", prefix = "hrrr/20250809/",
                             order_by_last_modified = TRUE, return_tail = TRUE, tail_n = 6)
}

}
\seealso{
[aws.s3::get_bucket()], [aws.s3::save_object()]
}
